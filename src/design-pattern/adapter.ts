/* 
适配器模式的作用是解决两个软件实体间的接口不兼容的问题。
使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。

适配器的别名是包装器（wrapper），这是一个相对简单的模式。
在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口时，
却发现这个接口的格式并不符合目前的需求。这时候有两种解决办法，
第一种是修改原来的接口实现，但如果原来的模块很复杂，
或者我们拿到的模块是一段别人编写的经过压缩的代码，
修改原接口就显得不太现实了。

第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，
客户只需要和适配器打交道。

如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。
适配器模式是一种“亡羊补牢”的模式，没有人会在程序的设计之初就使用它。
因为没有人可以完全预料到未来的事情，也许现在好好工作的接口，
未来的某天却不再适用于新系统，那么我们可以用适配器模式把旧接口包装成一个新的接口，
使它继续保持生命力。比如在JSON格式流行之前，很多cgi返回的都是XML格式的数据，
如果今天仍然想继续使用这些接口，显然我们可以创造一个XML-JSON的适配器。

适配器模式主要用来解决两个已有接口之间不匹配的问题，
它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。
适配器模式不需要改变已有的接口，就能够使它们协同作用。

装饰者模式和代理模式也不会改变原有对象的接口，
但装饰者模式的作用是为了给对象增加功能。
装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。
代理模式是为了控制对对象的访问，通常也只包装一次。
*/

const googleMap = {
  show() {
    console.log('展示google地图');
  },
};

const baiduMap = {
  display() {
    console.log('展示baidu地图');
  },
};

const baiduMapAdapter = {
  show() {
    baiduMap.display();
  },
};

export function showMap(map: { show: () => void }) {
  map.show();
}

showMap(googleMap);
showMap(baiduMapAdapter);
